def withAWSCreds(body) {
    withEnv([
        "AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID}",
        "AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY}",
        "AWS_SESSION_TOKEN=${env.AWS_SESSION_TOKEN}",
        "AWS_REGION=${env.AWS_REGION}"
    ]) {
        body()
    }
}

pipeline {
    agent { label 'build-node' }

    tools {
        allure 'allure'
    }

    parameters {
        string(name: 'RELEASE_VERSION', defaultValue: 'latest', description: 'Image version to use')
        choice(name: 'ENVIRONMENT_NAME', choices: ['test', 'dev', 'prod', 'sandbox'], description: 'Deployment environment')
    }

    environment {
        AWS_REGION = 'eu-central-1'
        AWS_REPOSITORY_URL = '214404897309.dkr.ecr.eu-central-1.amazonaws.com'
    }

    stages {
        stage('Determine url where run tests') {
            steps {
                script {
                    def urls = [
                        'test'   : 'https://test.npgw.xyz',
                        'dev'    : 'https://dev.npgw.xyz',
                        'prod'   : 'n/aYet',
                        'sandbox': 'https://sandbox.npgw.xyz'
                    ]
                    env.URL = urls[params.ENVIRONMENT_NAME] ?: error("Invalid environment: ${params.ENVIRONMENT_NAME}")
                }
            }
        }

        stage('Get Release Version') {
            steps {
                script {
                    if (params.RELEASE_VERSION == 'latest') {
                        env.RELEASE_VERSION = sh(script: """aws ecr describe-images --repository-name npgw/api-test --query 'sort_by(imageDetails,& imagePushedAt)[-1].imageTags[0]' --output text""", returnStdout: true).trim()
                    } else {
                        env.RELEASE_VERSION = params.RELEASE_VERSION
                    }
                }
            }
        }

        stage('Validate Release Version') {
            steps {
                script {
                    if (!env.RELEASE_VERSION) {
                        error("Release version is null. Exiting...")
                    }
                }
            }
        }

        stage('Checkout Code') {
            steps {
                dir('npgw-services') {
                   git credentialsId: 'github-pat', url: 'https://github.com/NPGW/npgw-services.git', branch: 'add-allure-reports'
                }
            }
        }

        stage('Determine AWS Role') {
            steps {
                script {
                    def roles = [
                        'test'   : 'arn:aws:iam::820242903147:role/npgw-jenkins-deploy-a-version-role',
                        'dev'    : 'arn:aws:iam::872515291967:role/npgw-jenkins-deploy-a-version-role',
                        'prod'   : 'arn:aws:iam::721719382766:role/npgw-jenkins-deploy-a-version-role',
                        'sandbox': 'arn:aws:iam::225989351233:role/npgw-jenkins-deploy-a-version-role'
                    ]
                    env.ROLE_TO_ASSUME = roles[params.ENVIRONMENT_NAME] ?: error("Invalid environment: ${params.ENVIRONMENT_NAME}")
                }
            }
        }

        stage('Assume Correct AWS Role') {
            steps {
                script {
                    def credentialsJson = sh(script: """
                        aws sts assume-role \
                            --role-arn ${env.ROLE_TO_ASSUME} \
                            --role-session-name JenkinsUploadSession
                        """, returnStdout: true).trim()

                    env.AWS_ACCESS_KEY_ID = sh(script: "echo '${credentialsJson}' | jq -r '.Credentials.AccessKeyId'", returnStdout: true).trim()
                    env.AWS_SECRET_ACCESS_KEY = sh(script: "echo '${credentialsJson}' | jq -r '.Credentials.SecretAccessKey'", returnStdout: true).trim()
                    env.AWS_SESSION_TOKEN = sh(script: "echo '${credentialsJson}' | jq -r '.Credentials.SessionToken'", returnStdout: true).trim()
                }
            }
        }

        /*
        stage('Seed AWS Data') {
            steps {
                script {
                    echo "Seeding AWS data for environment: ${params.ENVIRONMENT_NAME}"
                    dir('npgw-services/tests/docker/docker-compose') {
                        withAWSCreds {
                            sh """
                                chmod +x aws-seed-script.sh
                                ./aws-seed-script.sh
                            """
                        }
                    }
                }
            }
        }
        */

        stage('Run Api Tests') {
            steps {
                script {
                    def imageUrl = "${env.AWS_REPOSITORY_URL}/npgw/api-test:${env.RELEASE_VERSION}"
                    echo "DEBUG - Using Docker image: ${imageUrl}"

                    sh """
                    unset AWS_ACCESS_KEY_ID
                    unset AWS_SECRET_ACCESS_KEY
                    unset AWS_SESSION_TOKEN
                    aws ecr get-login-password --region ${env.AWS_REGION} | docker login --username AWS --password-stdin ${env.AWS_REPOSITORY_URL}

                    mkdir -p allure-results
                    set +e
                    docker run --rm \\
                        -e SERVICE_MERCHANT_URL=${env.URL}/merchant-v1 \\
                        -e SERVICE_MERCHANT_ID=merchant-server-ngenius \\
                        -e SERVICE_MERCHANT_USER_EMAIL=test@email.com \\
                        -e SERVICE_MERCHANT_USER_PASSWORD=Qwerty123! \\
                        -e SERVICE_PORTAL_URL=${env.URL}/portal-v1 \\
                        -e SERVICE_PORTAL_ID=merchant-server-ngenius \\
                        -e SERVICE_PORTAL_USER_EMAIL=test@email.com \\
                        -e SERVICE_PORTAL_USER_PASSWORD=Qwerty123! \\
                        -e TEST_ENVIRONMENT=AWS \\
                        -v `pwd`/allure-results:/app/target/allure-results \\
                        ${imageUrl}
                    echo "Container exited with code \$?"
                    set -e
                    """
                }
            }
        }

        stage('DEBUG 1 - Pre-Run: Host Directory Check') {
            steps {
                sh '''
                echo "--- Checking local allure-results before container ---"
                mkdir -p allure-results
                ls -lah allure-results
                echo "test" > allure-results/host-write-check.txt
                '''
            }
        }

        stage('DEBUG 2 - Volume Mount Write Test') {
            steps {
                sh '''
                echo "--- Spawning temp container to write test file ---"

                docker run --rm \
                  -v `pwd`/allure-results:/app/target/allure-results \
                  alpine \
                  sh -c 'echo "container-test" > /app/target/allure-results/container-write-check.txt'
                '''
            }
        }

        stage('DEBUG 3 - Post-Write Check') {
            steps {
                sh '''
                echo "--- Checking content in host allure-results ---"
                ls -lah allure-results

                echo "--- Showing content of write check files ---"
                cat allure-results/host-write-check.txt || echo "❌ host-write-check.txt missing"
                cat allure-results/container-write-check.txt || echo "❌ container-write-check.txt missing"
                '''
            }
        }

        stage('DEBUG 4 - Run Image and Inspect Inside') {
            steps {
                script {
                    def imageUrl = "${env.AWS_REPOSITORY_URL}/npgw/api-test:${env.RELEASE_VERSION}"

                    sh """
                    echo "--- Running full test image (with entrypoint) ---"

                    docker run --rm \\
                      -v `pwd`/allure-results:/app/target/allure-results \\
                      ${imageUrl}

                    echo "--- Done running container ---"
                    """
                }
            }
        }

        stage('DEBUG 5 - Final Allure Result Check') {
            steps {
                sh '''
                echo "--- Final state of allure-results directory ---"
                ls -lahR allure-results
                '''
            }
        }

        stage('DEBUG 6 - Check for Allure Listeners in JAR') {
            steps {
                script {
                    def imageUrl = "${env.AWS_REPOSITORY_URL}/npgw/api-test:${env.RELEASE_VERSION}"

                    sh """
                    echo "--- Checking JAR contents inside the container ---"

                    docker run --rm \\
                      --entrypoint /bin/sh \\
                      ${imageUrl} \\
                      -c '
                        echo "--- Looking for Allure-related files in merchant-api-test-jar ---"
                        unzip -l merchant-api-test-jar-with-dependencies.jar | grep -i allure || echo "❌ No allure-related classes found"

                        echo "--- Looking for META-INF/services in portal-api-test-jar ---"
                        unzip -l portal-api-test-jar-with-dependencies.jar | grep META-INF/services || echo "❌ No service registration found"

                        echo "--- Looking for allure.properties ---"
                        unzip -l portal-api-test-jar-with-dependencies.jar | grep allure.properties || echo "❌ No allure.properties"
                      '
                    """
                }
            }
        }

        stage('DEBUG - Inspect Container Internally After Test Run') {
            steps {
                script {
                    def imageUrl = "${env.AWS_REPOSITORY_URL}/npgw/api-test:${env.RELEASE_VERSION}"

                    sh """
                    docker run --rm \\
                      --entrypoint /bin/sh \\
                      -v `pwd`/debug-out:/app/target/allure-results \\
                      ${imageUrl} \\
                      -c '
                        echo "--- Inside container: /app/target/allure-results ---"
                        ls -lahR /app/target/allure-results || echo "❌ Not found"

                        echo "--- Check filesystem write permissions ---"
                        touch /app/target/allure-results/test.touch && echo "✅ Writable" || echo "❌ Not writable"
                      '
                    """
                }
            }
        }

        stage('DEBUG - Host Volume Check') {
            steps {
                sh '''
                echo "--- On Jenkins host, show debug-out contents ---"
                ls -lahR debug-out || echo "❌ debug-out missing"
                '''
            }
        }


        stage('Download Previous Allure History from S3') {
            steps {
                withAWSCreds {
                    sh """
                        mkdir -p allure-results/history
                        aws s3 cp s3://npgw-testing/allure-history/${params.ENVIRONMENT_NAME}/history/ allure-results/history/ --recursive || true
                    """
                }
            }
        }

        stage('Generate Allure Report') {
            steps {
                withEnv(["PATH+ALLURE=${tool 'allure'}/bin"]) {

                    echo "DEBUG - Contents of allure-results:"
                    sh 'ls -R allure-results'

                    sh 'allure generate allure-results --clean -o allure-report'
                }
            }
        }

        stage('Upload Allure Report and History to S3') {
            steps {
                script {
                    withAWSCreds {
                        sh """
                            aws s3 cp allure-report/ s3://npgw-testing/allure-history/${params.ENVIRONMENT_NAME}/report/ --recursive
                            aws s3 cp allure-report/history/ s3://npgw-testing/allure-history/${params.ENVIRONMENT_NAME}/history/ --recursive
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            allure([
                includeProperties: false,
                jdk: '',
                results: [[path: 'allure-results']]
            ])
            cleanWs()
        }
    }
}